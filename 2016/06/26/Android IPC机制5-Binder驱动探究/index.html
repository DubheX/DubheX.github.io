<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Binder," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="概述Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，整个通信过程从client进程到server进程,从内核态到用户态都涉及到了，前面几篇文章也讲了很多。而真正在Client和Server两端建立通信的基础设施便是Binder Driver。总结一下，Android系统Binder机制中的四个组件Client、Server、Servic">
<meta property="og:type" content="article">
<meta property="og:title" content="Android IPC机制5-Binder驱动探究">
<meta property="og:url" content="http://dubhex.com/2016/06/26/Android IPC机制5-Binder驱动探究/index.html">
<meta property="og:site_name" content="DubheX's Blog">
<meta property="og:description" content="概述Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，整个通信过程从client进程到server进程,从内核态到用户态都涉及到了，前面几篇文章也讲了很多。而真正在Client和Server两端建立通信的基础设施便是Binder Driver。总结一下，Android系统Binder机制中的四个组件Client、Server、Servic">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1689700-2cf166141f7d1167.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1689700-eba802ca430e1101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1689700-2b9d50c772eca181.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1689700-56089caf42d5bf9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1689700-7198524071020440.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-07-13T14:41:10.890Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android IPC机制5-Binder驱动探究">
<meta name="twitter:description" content="概述Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，整个通信过程从client进程到server进程,从内核态到用户态都涉及到了，前面几篇文章也讲了很多。而真正在Client和Server两端建立通信的基础设施便是Binder Driver。总结一下，Android系统Binder机制中的四个组件Client、Server、Servic">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1689700-2cf166141f7d1167.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Android IPC机制5-Binder驱动探究 | DubheX's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?969589c3b5a707b9bc85e22c68f00a61";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DubheX's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'LbTKfyCUc6oLGYwwZ8hu','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android IPC机制5-Binder驱动探究
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-26T00:00:00+08:00" content="2016-06-26">
              2016-06-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/26/Android IPC机制5-Binder驱动探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/26/Android IPC机制5-Binder驱动探究/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Client进程通过RPC(Remote Procedure Call Protocol)与Server通信，整个通信过程从client进程到server进程,从内核态到用户态都涉及到了，前面几篇文章也讲了很多。而真正在Client和Server两端建立通信的基础设施便是Binder Driver。总结一下，Android系统Binder机制中的四个组件Client、Server、Service Manager和Binder驱动程序的关系如下图所示 （图片来自<a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">老罗博客</a>）</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/1689700-2cf166141f7d1167.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Binder通信架构">：</p>
<p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。后面会详细讲解这几个函数，但为了后面的理解，先来看看内核态、用户态、系统调用等概念。<br><a id="more"></a></p>
<h3 id="1-1-用户态与内核态"><a href="#1-1-用户态与内核态" class="headerlink" title="1.1 用户态与内核态"></a>1.1 用户态与内核态</h3><p>以创建进程来说，无论是Linux亦或是windows，对于任何操作系统来说，其都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做。类似的操作还有很多，所以就操作系统就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。</p>
<p>特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。</p>
<p>而arm cpu的特权模式就比较多了，有7种。但是只有一种是用户模式，其他的都是特权模式。</p>
<p>现在我们从特权级的调度来理解用户态和内核态就比较好理解了，以x86来说当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在0级特权级上时，就可以称之为运行在内核态。<br>虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。</p>
<h3 id="1-2-如何切换用户态和内核态"><a href="#1-2-如何切换用户态和内核态" class="headerlink" title="1.2 如何切换用户态和内核态"></a>1.2 如何切换用户态和内核态</h3><p>Linux提供了<em>系统调用</em>作为切换用户态与内核态的机制。其底层是通过<em>中断机制</em>来实现的。简单的说，当用户态执行到需要内核态执行的代码时，会产生一个中断信号，cpu收到信号后会根据中断信号传递的信息进入不同的中断函数，当中断函数执行完毕后，就会回到用户态。</p>
<h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>下面以serviceManager的启动为例,详细分析Binder驱动的几个核心函数,先来看看ServiceManager的启动过程(代码位于<code>service_manager.c</code>)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现,其主要有以下几个步骤</p>
<ul>
<li>打开binder驱动: binder_open(128*1024);</li>
<li>通知Binder驱动程序它成为Binder通信的上下文管理者:binder_become_context_manager(bs);</li>
<li>进入循环等待请求的到来：binder_loop(bs, svcmgr_handler);</li>
</ul>
<h3 id="2-1-binder-open-service-manager"><a href="#2-1-binder-open-service-manager" class="headerlink" title="2.1 binder_open(service_manager)"></a>2.1 binder_open(service_manager)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_state *bs;</span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot open device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot map device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> check version */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过文件操作函数open来打开/dev/binder设备文件。设备文件/dev/binder是在Binder驱动程序模块初始化的时候创建的，我们先看一下这个设备文件的创建过程。进入到kernel/common/drivers/staging/android目录中，打开binder.c文件，可以看到模块初始化入口binder_init：</p>
<h3 id="2-2-binder-init"><a href="#2-2-binder-init" class="headerlink" title="2.2 binder_init:"></a>2.2 binder_init:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="comment">//创建名为binder的工作队列</span></span><br><span class="line">	binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>); </span><br><span class="line">	<span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>); </span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 注册misc设备</span></span><br><span class="line">	ret = misc_register(&amp;binder_miscdev);   </span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">		... <span class="comment">//在debugfs文件系统中创建一系列的文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR, <span class="comment">//次设备号 动态分配</span></span><br><span class="line">	.name = <span class="string">"binder"</span>,     <span class="comment">//设备名</span></span><br><span class="line">	.fops = &amp;binder_fops  <span class="comment">//设备的文件操作结构，这是file_operations结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>debugfs_create_dir</code>是指在debugfs文件系统中创建一个目录，返回值是指向dentry的指针。注册misc设备，miscdevice结构体，便是前面注册misc设备时传递进去的参数,<code>file_operations</code>结构体,指定相应文件操作的方法。</p>
<p>回到2.1，前面的前面的binder_open函数执行语句会执行到<code>bs-&gt;fd = open(&quot;/dev/binder&quot;, O_RDWR);</code>,这句代码就是一个系统调用,最终会执行到binder驱动的binder_open方法</p>
<h3 id="2-3-binder-open-Binder驱动"><a href="#2-3-binder-open-Binder驱动" class="headerlink" title="2.3 binder_open(Binder驱动)"></a>2.3 binder_open(Binder驱动)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> binder_proc *proc; <span class="comment">// binder进程 【见附录3.1】</span></span><br><span class="line"></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); <span class="comment">// 为binder_proc结构体在分配kernel内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;   <span class="comment">//将当前线程的task保存到binder进程的tsk</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo); <span class="comment">//初始化todo列表</span></span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait); <span class="comment">//初始化wait队列</span></span><br><span class="line">	proc-&gt;default_priority = task_nice(current);  <span class="comment">//将当前进程的nice值转换为进程优先级</span></span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);   <span class="comment">//同步锁，因为binder支持多线程访问</span></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC); <span class="comment">//BINDER_PROC对象创建数加1</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); <span class="comment">//将proc_node节点添加到binder_procs为表头的队列</span></span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;       <span class="comment">//file文件指针的private_data变量指向binder_proc数据</span></span><br><span class="line">	binder_unlock(__func__); <span class="comment">//释放同步锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主要作用是创建一个struct binder_proc数据结构来保存打开设备文件/dev/binder的进程的上下文信息，并且将这个进程上下文信息保存在打开文件结构struct file的私有数据成员变量private_data中，这样，在执行其它文件操作时，就通过打开文件结构struct file来取回这个进程上下文信息了。这个进程上下文信息同时还会保存在一个全局哈希表binder_procs中，驱动程序内部使用。binder_procs定义在文件的开头：<code>static HLIST_HEAD(binder_procs);</code>其保存了所有的binder_proc结构，每次新创建的binder_proc对象都会加入binder_procs链表中。<code>binder_proc</code>见4.1</p>
<p>这样，打开设备文件/dev/binder的操作就完成了，接着是对打开的设备文件进行内存映射操作mmap：</p>
<h3 id="2-4-binder-mmap"><a href="#2-4-binder-mmap" class="headerlink" title="2.4 binder_mmap"></a>2.4 binder_mmap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> vm_struct *area; <span class="comment">//内核虚拟空间</span></span><br><span class="line">	<span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="keyword">struct</span> binder_buffer *buffer;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;tsk != current)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;  <span class="comment">//保证映射内存大小不超过4M</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_mmap_lock);  <span class="comment">//同步锁</span></span><br><span class="line">	<span class="comment">//分配一个连续的内核虚拟空间，与进程虚拟空间大小一致</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); </span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer = area-&gt;addr; <span class="comment">//指向内核虚拟空间的地址</span></span><br><span class="line">	<span class="comment">//地址偏移量 = 用户虚拟地址空间 - 内核虚拟地址空间</span></span><br><span class="line">	proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer; </span><br><span class="line">	mutex_unlock(&amp;binder_mmap_lock); <span class="comment">//释放锁</span></span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//分配物理页的指针数组，大小等于用户虚拟地址内存/4k；</span></span><br><span class="line">	proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">	vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配物理页面，同时映射到内核空间和进程空间，目前只分配1个page的物理页 【见2.5】</span></span><br><span class="line">	<span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	buffer = proc-&gt;buffer; <span class="comment">//binder_buffer对象 指向proc的buffer地址</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;buffers); <span class="comment">//创建进程的buffers链表头</span></span><br><span class="line">	list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); <span class="comment">//将binder_buffer地址 加入到所属进程的buffers队列</span></span><br><span class="line">	buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//将空闲buffer放入proc-&gt;free_buffers中</span></span><br><span class="line">	binder_insert_free_buffer(proc, buffer); </span><br><span class="line">	<span class="comment">//异步可用空间大小为buffer总大小的一半。</span></span><br><span class="line">	proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">	barrier();</span><br><span class="line">	proc-&gt;files = get_files_struct(current);</span><br><span class="line">	proc-&gt;vma = vma;</span><br><span class="line">	proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...<span class="comment">// 错误flags跳转处，free释放内存之类的操作</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_mmap通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。其中user_buffer_offset是虚拟进程地址与虚拟内核地址的差值，也就是说同一物理地址，当内核地址为kernel_addr，则进程地址为proc_addr = kernel_addr + user_buffer_offset。可以用下面的图片来方便理解<br> <img src="http://upload-images.jianshu.io/upload_images/1689700-eba802ca430e1101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="binder_mmap"></p>
<p>在上面的函数里同时出现了struct vm_area_struct和struct vm_struct。struct vm_area_struct，它表示的是一块连续的虚拟地址空间区域，struct vm_struct，这个数据结构也是表示一块连续的虚拟地址空间区域，那么，这两者的区别是什么呢？在Linux中，struct vm_area_struct表示的虚拟地址是给进程使用的，而struct vm_struct表示的虚拟地址是给内核使用的，它们对应的物理页面都可以是不连续的。struct vm_area_struct表示的地址空间范围是0~3G，而struct vm_struct表示的地址空间范围是(3G + 896M + 8M) ~ 4G。struct vm_struct表示的地址空间范围为什么不是3G~4G呢？原来，3G ~ (3G + 896M)范围的地址是用来映射连续的物理页面的，这个范围的虚拟地址和对应的实际物理地址有着简单的对应关系，即对应0~896M的物理地址空间，而(3G + 896M) ~ (3G + 896M + 8M)是安全保护区域（例如，所有指向这8M地址空间的指针都是非法的），因此struct vm_struct使用(3G + 896M + 8M) ~ 4G地址空间来映射非连续的物理页面。</p>
<h3 id="2-5-binder-update-page-range"><a href="#2-5-binder-update-page-range" class="headerlink" title="2.5 binder_update_page_range"></a>2.5 binder_update_page_range</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc, <span class="keyword">int</span> allocate,</span><br><span class="line">				    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,  <span class="keyword">struct</span> vm_area_struct *vma)</span>	</span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret;</span><br><span class="line">		<span class="keyword">struct</span> page **page_array_ptr;</span><br><span class="line">		page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line">		*page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);  <span class="comment">//分配物理内存</span></span><br><span class="line">		<span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp_area.addr = page_addr;</span><br><span class="line">		tmp_area.size = PAGE_SIZE + PAGE_SIZE;</span><br><span class="line">		page_array_ptr = page;</span><br><span class="line">		ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr); <span class="comment">//物理空间映射到虚拟内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">goto</span> err_map_kernel_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		user_page_addr = (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">		ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]); <span class="comment">//物理空间映射到虚拟进程空间</span></span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_update_page_range 主要完成工作：分配物理空间，将物理空间映射到内核空间，将物理空间映射到进程空间。 当然binder_update_page_range<br>既可以分配物理页面，也可以释放物理页面。</p>
<h3 id="2-6-binder-ioctl"><a href="#2-6-binder-ioctl" class="headerlink" title="2.6 binder_ioctl"></a>2.6 binder_ioctl</h3><p>讲了这么多,<code>service_manager</code>的<code>main()</code>的binder_open执行完毕了,接下来代码就走到了<code>binder_become_context_manager(bs)</code>,来看看这个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(<span class="keyword">struct</span> binder_state *bs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数内部非常简单,直接调用的<code>ioctl</code>函数,通过上面的经验,我们可以知道<code>ioctl</code>也是个系统调用,最终是执行的是内核态的binder_ioctl函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">struct</span> binder_thread *thread;  <span class="comment">// binder线程</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">	<span class="comment">//进入休眠状态，直到中断唤醒</span></span><br><span class="line">	ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line">	<span class="comment">//获取binder_thread</span></span><br><span class="line">	thread = binder_get_thread(proc); </span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ:  <span class="comment">//进行binder的读写操作</span></span><br><span class="line">		ret = binder_ioctl_write_read(filp, cmd, arg, thread); <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_MAX_THREADS: <span class="comment">//设置binder最大支持的线程数</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR: <span class="comment">//成为binder的上下文管理者，也就是ServiceManager成为守护进程</span></span><br><span class="line">		ret = binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_THREAD_EXIT:   <span class="comment">//当binder线程退出，释放binder线程</span></span><br><span class="line">		binder_free_thread(proc, thread);</span><br><span class="line">		thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_VERSION: &#123;  <span class="comment">//获取binder的版本号</span></span><br><span class="line">		<span class="keyword">struct</span> binder_version __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (thread)</span><br><span class="line">		thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line">	wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line">err_unlocked:</span><br><span class="line">	trace_binder_ioctl_done(ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>binder_ioctl()</code>函数负责在两个进程间收发IPC数据和IPC reply数据。是一个非常重要的函数,其参数列表为<code>ioctl(文件描述符，ioctl命令，数据类型)</code></p>
<ul>
<li>文件描述符，是通过open()方法打开Binder Driver后返回值；</li>
<li>ioctl命令和数据类型是一体的，不同的命令对应不同的数据类型,如声明成为service_manager声明称为上下文管理者就是<code>BINDER_SET_CONTEXT_MGR</code><br> 继续分析这个函数之前，又要解释两个数据结构了，一个是struct binder_thread结构体，顾名思久，它表示一个线程，这里就是执行binder_become_context_manager函数的线程了。具体定义见4.2<br>proc表示这个线程所属的进程。struct binder_proc有一个成员变量threads，它的类型是rb_root，它表示一查红黑树，把属于这个进程的所有线程都组织起来，struct binder_thread的成员变量rb_node就是用来链入这棵红黑树的节点了。looper成员变量表示线程的状态，它可以取下面这几个值：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;  </span><br><span class="line">    BINDER_LOOPER_STATE_REGISTERED  = <span class="number">0x01</span>,  <span class="comment">// 已注册</span></span><br><span class="line">    BINDER_LOOPER_STATE_ENTERED     = <span class="number">0x02</span>,  <span class="comment">// 已进入</span></span><br><span class="line">    BINDER_LOOPER_STATE_EXITED      = <span class="number">0x04</span>,  <span class="comment">// 已退出</span></span><br><span class="line">    BINDER_LOOPER_STATE_INVALID     = <span class="number">0x08</span>,  <span class="comment">// 非法</span></span><br><span class="line">    BINDER_LOOPER_STATE_WAITING     = <span class="number">0x10</span>,  <span class="comment">// 等待中</span></span><br><span class="line">    BINDER_LOOPER_STATE_NEED_RETURN = <span class="number">0x20</span>  <span class="comment">// 需要返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>另外一个数据结构是struct binder_node,详见4.3。它表示一个binder实体， rb_node和dead_node组成一个联合体。 如果这个Binder实体还在正常使用，则使用rb_node来连入proc-&gt;nodes所表示的红黑树的节点，这棵红黑树用来组织属于这个进程的所有Binder实体；如果这个Binder实体所属的进程已经销毁，而这个Binder实体又被其它进程所引用，则这个Binder实体通过dead_node进入到一个哈希表中去存放。proc成员变量就是表示这个Binder实例所属于进程了。</p>
<p>下面来看看ioctl中的几个重要函数</p>
<h4 id="2-6-1-binder-get-thread"><a href="#2-6-1-binder-get-thread" class="headerlink" title="2.6.1 binder_get_thread()"></a>2.6.1 binder_get_thread()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> binder_thread *<span class="title">binder_get_thread</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> binder_thread *thread = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> rb_node *parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> rb_node **p = &amp;proc-&gt;threads.rb_node;</span><br><span class="line">	<span class="keyword">while</span> (*p) &#123;  <span class="comment">//根据当前进程的pid，从binder_proc中查找相应的binder_thread</span></span><br><span class="line">		parent = *p;</span><br><span class="line">		thread = rb_entry(parent, <span class="keyword">struct</span> binder_thread, rb_node);</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">			p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL); <span class="comment">//新建binder_thread结构体</span></span><br><span class="line">		<span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">		thread-&gt;proc = proc;</span><br><span class="line">		thread-&gt;pid = current-&gt;pid;  <span class="comment">//保存当前进程(线程)的pid</span></span><br><span class="line">		init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">		INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">		rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">		rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">		thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">		thread-&gt;return_error = BR_OK;</span><br><span class="line">		thread-&gt;return_error2 = BR_OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把当前线程current的pid作为键值，在进程proc-&gt;threads表示的红黑树中进行查找，看是否已经为当前线程创建过了binder_thread信息。在这个场景下，由于当前线程是第一次进到这里，所以肯定找不到，即*p == NULL成立，于是，就为当前线程创建一个线程上下文信息结构体binder_thread，并初始化相应成员变量，并插入到proc-&gt;threads所表示的红黑树中去，下次要使用时就可以从proc中找到了。</p>
<h3 id="2-6-2-binder-ioctl-write-read"><a href="#2-6-2-binder-ioctl-write-read" class="headerlink" title="2.6.2 binder_ioctl_write_read()"></a>2.6.2 binder_ioctl_write_read()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span><br><span class="line">				<span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">	<span class="keyword">struct</span> binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123; <span class="comment">//把用户空间数据ubuf拷贝到bwr</span></span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//当写缓存中有数据，则执行binder写操作</span></span><br><span class="line">		ret = binder_thread_write(proc, thread,</span><br><span class="line">					  bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); </span><br><span class="line">		trace_binder_write_done(ret); </span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//当写失败，再将bwr数据写回用户空间，并返回</span></span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) </span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//当读缓存中有数据，则执行binder读操作</span></span><br><span class="line">		ret = binder_thread_read(proc, thread, </span><br><span class="line">					  bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed,</span><br><span class="line">					  filp-&gt;f_flags &amp; O_NONBLOCK); </span><br><span class="line">		trace_binder_read_done(ret);</span><br><span class="line">		<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">			wake_up_interruptible(&amp;proc-&gt;wait); <span class="comment">//进入休眠，等待中断唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//当读失败，再将bwr数据写回用户空间，并返回</span></span><br><span class="line">			<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) </span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123; <span class="comment">//将内核数据bwr拷贝到用户空间ubuf</span></span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体流程如下:</p>
<ol>
<li>首先把用户空间数据拷贝到内核空间bwr；</li>
<li>当bwr写缓存中有数据，则执行binder写操作；当写失败，再将bwr数据写回用户空间，并退出；</li>
<li>当bwr读缓存中有数据，则执行binder读操作；当读失败，再将bwr数据写回用户空间，并退出；</li>
<li>最后把内核数据bwr拷贝到用户空间。</li>
</ol>
<p>这里涉及两个核心方法binder_thread_write()和binder_thread_read()方法,<em>请求处理</em>过程是通过binder_thread_write()方法，该方法用于处理Binder协议中的请求码。当binder_buffer存在数据，binder线程的写操作循环执行。</p>
<p>而<em>响应处理</em>过程是通过binder_thread_read()方法，该方法根据不同的binder_work-&gt;type以及不同状态，生成相应的响应码。</p>
<h3 id="2-7-小节"><a href="#2-7-小节" class="headerlink" title="2.7 小节"></a>2.7 小节</h3><p>上面列出了这么多代码,其实有些细节我也没有深入学习,不过对于binder通信的主要流程还算是比较熟悉了。其主要流程有以下几点(以service_manager启动并成为上下文管理者为例)</p>
<ol>
<li>binder_init: 注册驱动,</li>
<li>binder_open: 创建一个struct binder_proc数据结构来保存打开设备文件/dev/binder的进程的上下文信息</li>
<li>binder_mmap :  映射进程虚拟地址和内核虚拟地址到同一个物理地址</li>
<li>binder_ioctl : 两个进程间收发IPC数据和IPC reply数据</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面的一章里,通过代码详细分析了binder通信的几个核心函数(binder_thread_write()与binder_thread_write()没有展开讲),下面从宏观上做些总结</p>
<h3 id="内存关系"><a href="#内存关系" class="headerlink" title="内存关系"></a>内存关系</h3><p>先上个图(感谢<a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="external">gityuan</a>大大)<br><img src="http://upload-images.jianshu.io/upload_images/1689700-2b9d50c772eca181.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="binder_physical_memory"></p>
<p>这个图生动的说明了binder通信的内存原理。一直说的binder驱动的只需一次copy的奥妙就是内存映射，android通过一块物理内存地址映射到一个进程中的用户空间和内核空间的两个地址，就可以让client到server的数据传递只需从client的用户空间copy到内核空间，然后由于server端的用户空间映射了和内核空间data同一个地址，所以就能直接得到数据，避免二次copy，提高了性能。</p>
<p>图中的进程所有的4g内存是虚拟内存,并非进程实际能得到4g,至于为什么是4g,主要是由于32位cpu的内存寻址能力2^32,实际上binder能映射的虚拟地址空间大小为3G+896M+8M~4G=120m,而实际的物理内存更是被限制为&lt;4m,所以binder机制不适合大数据的传输。</p>
<p>对于进程和内核虚拟地址映射到同一个物理内存的操作是发生在数据接收端，而数据发送端还是需要将用户态的数据复制到内核态。那为何不直接让发送端和接收端直接映射到同一个物理空间，那样就连一次复制的操作都不需要了，0次复制操作那就与Linux标准内核的共享内存的IPC机制没有区别了，对于共享内存虽然效率高，但是对于多进程的同步问题比较复杂，而管道/消息队列等IPC需要复制2两次，效率较低。这里就不先展开讨论Linux现有的各种IPC机制跟Binder的详细对比，总之Android选择Binder的基于速度和安全性的考虑。<br>下面这图是从Binder在进程间数据通信的流程图，从图中更能明了Binder的内存转移关系:<br><img src="http://upload-images.jianshu.io/upload_images/1689700-56089caf42d5bf9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><p>下面这张张图生动的描述一次ipc 事物的完整流程：<br><img src="http://upload-images.jianshu.io/upload_images/1689700-7198524071020440.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="结构体附录"><a href="#结构体附录" class="headerlink" title="结构体附录"></a>结构体附录</h2><h3 id="4-1-binder-proc"><a href="#4-1-binder-proc" class="headerlink" title="4.1 binder_proc"></a>4.1 binder_proc</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_proc &#123;  </span><br><span class="line">    <span class="keyword">struct</span> hlist_node proc_node;  </span><br><span class="line">    <span class="keyword">struct</span> rb_root threads;  <span class="comment">//binder_thread红黑树的根节点</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root nodes;   <span class="comment">//binder_node红黑树的根节点,保存进程中的binder实体</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root refs_by_desc;  <span class="comment">//binder_ref红黑树的根节点(以handle为key)</span></span><br><span class="line">    <span class="keyword">struct</span> rb_root refs_by_node;  <span class="comment">//binder_ref红黑树的根节点（以ptr为key）</span></span><br><span class="line">    <span class="keyword">int</span> pid;                <span class="comment">//创建binder_proc的进程id</span></span><br><span class="line">    <span class="keyword">struct</span> vm_area_struct *vma;   <span class="comment">//指向进程虚拟地址空间的指针(用户态使用)</span></span><br><span class="line">    <span class="keyword">struct</span> task_struct *tsk;  </span><br><span class="line">    <span class="keyword">struct</span> files_struct *files;  </span><br><span class="line">    <span class="keyword">struct</span> hlist_node deferred_work_node;  </span><br><span class="line">    <span class="keyword">int</span> deferred_work;  </span><br><span class="line">    <span class="keyword">void</span> *buffer;    <span class="comment">//	映射的内核空间的起始地址</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;    <span class="comment">//内核空间与用户空间的地址偏移量</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> list_head buffers;  </span><br><span class="line">    <span class="keyword">struct</span> rb_root free_buffers;  </span><br><span class="line">    <span class="keyword">struct</span> rb_root allocated_buffers;  </span><br><span class="line">    <span class="keyword">size_t</span> free_async_space;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> page **pages;  </span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;    <span class="comment">//映射的内核空间大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_free;   <span class="comment">//可用内存总大小</span></span><br><span class="line">    <span class="keyword">struct</span> list_head todo;  </span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;  </span><br><span class="line">    <span class="keyword">struct</span> binder_stats stats;  </span><br><span class="line">    <span class="keyword">struct</span> list_head delivered_death;  </span><br><span class="line">    <span class="keyword">int</span> max_threads;    <span class="comment">//最大binder线程数</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads;  </span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;  </span><br><span class="line">    <span class="keyword">int</span> ready_threads;  </span><br><span class="line">    <span class="keyword">long</span> default_priority;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-binder-thread"><a href="#4-2-binder-thread" class="headerlink" title="4.2 binder_thread"></a>4.2 binder_thread</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_thread &#123;  </span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;   <span class="comment">//线程所属的进程</span></span><br><span class="line">    <span class="keyword">struct</span> rb_node rb_node;  </span><br><span class="line">    <span class="keyword">int</span> pid;    <span class="comment">//线程pid</span></span><br><span class="line">    <span class="keyword">int</span> looper;  <span class="comment">//looper的状态</span></span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *transaction_stack;  </span><br><span class="line">    <span class="keyword">struct</span> list_head todo;  </span><br><span class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span>  </span><br><span class="line">        <span class="comment">/* buffer. Used when sending a reply to a dead process that */</span>  </span><br><span class="line">        <span class="comment">/* we are also waiting on */</span>  </span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;  </span><br><span class="line">    <span class="keyword">struct</span> binder_stats stats;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###　4.3 binder_node<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_node &#123;  </span><br><span class="line">    <span class="keyword">int</span> debug_id;  </span><br><span class="line">    <span class="keyword">struct</span> binder_work work;  </span><br><span class="line">    <span class="keyword">union</span> &#123;  </span><br><span class="line">        <span class="keyword">struct</span> rb_node rb_node;  </span><br><span class="line">        <span class="keyword">struct</span> hlist_node dead_node;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;  </span><br><span class="line">    <span class="keyword">struct</span> hlist_head refs;  </span><br><span class="line">    <span class="keyword">int</span> internal_strong_refs;  </span><br><span class="line">    <span class="keyword">int</span> local_weak_refs;  </span><br><span class="line">    <span class="keyword">int</span> local_strong_refs;  </span><br><span class="line">    <span class="keyword">void</span> __user *ptr;  </span><br><span class="line">    <span class="keyword">void</span> __user *cookie;  </span><br><span class="line">    <span class="keyword">unsigned</span> has_strong_ref : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> pending_strong_ref : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> has_weak_ref : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> pending_weak_ref : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> has_async_transaction : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> accept_fds : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> min_priority : <span class="number">8</span>;  </span><br><span class="line">    <span class="keyword">struct</span> list_head async_todo;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-4-binder-buffer"><a href="#4-4-binder-buffer" class="headerlink" title="4.4  binder_buffer"></a>4.4  binder_buffer</h3><p>BInder地址空间被划分为一段一段,每一段都是由binder_buffer 来描述<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_buffer &#123;  </span><br><span class="line">    <span class="keyword">struct</span> list_head entry;   <span class="comment">//	buffer实体的地址</span></span><br><span class="line">    <span class="keyword">struct</span> rb_node rb_node;   <span class="comment">//红黑树节点,用于挂在binder_proc中的红黑树上</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span> : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> async_transaction : <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">unsigned</span> debug_id : <span class="number">29</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> binder_transaction *transaction;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> binder_node *target_node;  </span><br><span class="line">    <span class="keyword">size_t</span> data_size;  </span><br><span class="line">    <span class="keyword">size_t</span> offsets_size;  </span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>];  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>Binder机制确实是android中非常重要的一环，学习难度也很大。不过通过Binder的学习，也让我对android系统有了更深入的认识。在这个过程中，也对linux的ipc机制、系统调用、内存管理有了些了解，也终于是搞懂了红黑树，这也算是一些附带成果吧。<br>最后再次感谢<a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">罗升阳</a>及<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="external">gityuan</a>两位老师，他们的博客使我受益匪浅。希望以后自己也能有更多高质量的原创博文。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Binder/" rel="tag">#Binder</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/05/Android IPC机制4-ServiceManager的addService与getService实现/" rel="next" title="Android IPC机制4-ServiceManager的addService与getService实现">
                <i class="fa fa-chevron-left"></i> Android IPC机制4-ServiceManager的addService与getService实现
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/12/Android Apk安装过程分析/" rel="prev" title="Android Apk安装过程分析">
                Android Apk安装过程分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/06/26/Android IPC机制5-Binder驱动探究/"
     data-title="Android IPC机制5-Binder驱动探究"
     data-content=""
     data-url="http://dubhex.com/2016/06/26/Android IPC机制5-Binder驱动探究/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/26/Android IPC机制5-Binder驱动探究/"
           data-title="Android IPC机制5-Binder驱动探究" data-url="http://dubhex.com/2016/06/26/Android IPC机制5-Binder驱动探究/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xrven.com1.z0.glb.clouddn.com/profile_photo.jpg"
               alt="DubheX" />
          <p class="site-author-name" itemprop="name">DubheX</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/DubheX" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.cnblogs.com/xns1001/" target="_blank">
                  
                    <i class="fa fa-cnblogs"></i> cnblogs
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-用户态与内核态"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 用户态与内核态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-如何切换用户态和内核态"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 如何切换用户态和内核态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心方法"><span class="nav-number">2.</span> <span class="nav-text">核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-binder-open-service-manager"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 binder_open(service_manager)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-binder-init"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 binder_init:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-binder-open-Binder驱动"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 binder_open(Binder驱动)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-binder-mmap"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 binder_mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-binder-update-page-range"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 binder_update_page_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-binder-ioctl"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 binder_ioctl</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-binder-get-thread"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.6.1 binder_get_thread()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-binder-ioctl-write-read"><span class="nav-number">2.7.</span> <span class="nav-text">2.6.2 binder_ioctl_write_read()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-小节"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 小节</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存关系"><span class="nav-number">3.1.</span> <span class="nav-text">内存关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通信模型"><span class="nav-number">3.2.</span> <span class="nav-text">通信模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体附录"><span class="nav-number">4.</span> <span class="nav-text">结构体附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-binder-proc"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 binder_proc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-binder-thread"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 binder_thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-binder-buffer"><span class="nav-number">4.3.</span> <span class="nav-text">4.4  binder_buffer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写在最后"><span class="nav-number">5.</span> <span class="nav-text">写在最后</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DubheX</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"dubhex"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
